# 单一职责(SRP--Single-Responsibility Principle)
就一个类而言，应该只专注于做一件事和仅有一个引起它变化的原因。所谓职责，我们可以理解他为功能，就是设计的这个类功能应该只有一个，
而不是两个或更多。或者也可以理解为引起变化的原因，当你发现有两个变化会要求我们修改这个类，那么你就要考虑撤分这个类了。因为职责
是变化的一个轴线，当需求变化时，该变化会反映类的职责的变化。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责变化
可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。使用SRP注意点：
1. 一个合理的类，应该仅有一个引起它变化的原因，即单一职责； 
2. 在没有变化征兆的情况下应用SRP或其他原则是不明智的； 
3. 在需求实际发生变化时就应该应用SRP等原则来重构代码； 
4. 使用测试驱动开发会迫使我们在设计出现臭味之前分离不合理代码； 
5. 如果测试不能迫使职责分离，僵化性和脆弱性的臭味会变得很强烈，那就应该用Facade或Proxy模式对代码重构；

SRP优点：消除耦合，减小因需求变化引起代码僵化。 


# 开闭原则(OCP--Open-Closed Principle)
+ 说明：对扩展开放，对修改关闭。 
+ 优点：按照OCP原则设计出来的系统，降低了程序各部分之间的耦合性，其适应性、灵活性、稳定性都比较好。当已有软件系统需要增加新的功能时，
  不需要对作为系统基础的抽象层进行修改，只需要在原有基础上附加新的模块就能实现所需要添加的功能。增加的新模块对原有的模块完全没有影响
  或影响很小，这样就无须为原有模块进行重新测试。 
+ 如何实现“开-闭”原则?
  在面向对象设计中，不允许更改的是系统的抽象层，而允许扩展的是系统的实现层。换言之，定义一个一劳永逸的抽象设计层，允许尽可能多的行为在
  实现层被实现。解决问题关键在于抽象化，抽象化是面向对象设计的第一个核心本质。对一个事物抽象化，实质上是在概括归纳总结它的本质。抽象让
  我们抓住最最重要的东西，从更高一层去思考。这降低了思考的复杂度，我们不用同时考虑那么多的东西。换言之，我们封装了事物的本质，看不到任
  何细节。在面向对象编程中，通过抽象类及接口，规定了具体类的特征。作为抽象层，相对稳定，不需更改，从而满足“对修改关闭”。而从抽象类导出
  的具体类可以改变系统的行为，从而满足“对扩展开放”。对实体进行扩展时，不必改动软件的源代码或者二进制代码。关键在于抽象。 

    
    开放封闭原则：
	软件实体(类，模块，函数等)应该是可以扩展但不可以修改的。
	两个特征：对于扩展是开放的(Open for extension)，对于更改是关闭的(Closed for modification)。
	无论模块多么封闭，都会存在一些对之无法封闭的变化。既然不可能完全封闭，设计人员必须对他所涉及的模块应该对哪种变化封闭做出选择。
	他必须猜测出最有可能发生变化的种类，然后构造抽象来隔离那些变化。
	我们在最初编写代码时，假设变化不会发生，当变化发生时，我们就要创建抽象来隔离以后可能发生的同类变化。
	例如: 客户刚开始只有加法需求。
		设计代码:  客户端类---->加法类
		客户后边又增加减法需求。变化发生了，这时候我们不能仅仅在加法类上修改就完事，就要考虑后边可能会发生的乘法，除法...等变化。
		所以应该抽象出一个运算类出来，然后由加法类，减法类去继承它。后边即使再发生增加乘法，除法，平方根等运算，只要增加相应的运算
		子类就可以了。		 
	面对需求，对程序的改动是通过增加代码来完成的，而不是更改现有的代码，这就是开放-封闭原则的精髓所在。
	开放封闭原则是面向对象设计的核心所在，通过遵循这一原则就能带来易扩展、易维护、易复用、灵活多样的优质代码。
	但是开发人员需要注意，仅对那些出现频繁变化的部分作出抽象，而不可时刻都做抽象，拒绝不成熟的抽象和抽象本身一样重要。
	 

# 里氏代换原则(LSP--Liskov Substitution Principle)
+ 说明：子类型必须能够完全替换它的基类型。一个软件实体如果使用的是一个基类，那么当把这个基类替换成继承该基类的子类时，程序的行为不会发生
  任何变化，软件实体察觉不出基类对象和子类对象的区别。 
+ 优点：可以很容易的实现同一父类下各个子类的互换，而客户端可以毫不察觉。


    里氏代换原则：子类型必须能够替换掉他们的父类型。
	一个软件实体，如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说
	在软件设计里，把父类都替换成它的子类，程序行为没有变化，简单的说，子类型必须能够替换掉它的父类型。
	
	举例：在面向对象设计时，一个是鸟类，一个是企鹅，如果鸟是可以飞的，企鹅不能飞，那么企鹅能继承鸟这个类吗？
	  	 日常生活中，答案是肯定的。但是在软件开发中，是绝对不可以的，因为假如能继承的话，企鹅不能以它的父类
	  	 鸟的身份出现，因为它飞不了，程序能察觉出来。
	只有子类可以替换掉父类，软件单位的功能不受影响，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
	比如猫是继承动物类的，它可以以动物的身份具有吃、喝、跑、叫的行为，假如有一天，我们需要狗、牛、羊也具有类似的
	行为，由于它们都可以继承动物，所以除了更改实例化的地方，程序其他处不用改变。
	      Anmal an = new Cat();
	      an.吃();
	      an.喝();
	      an.跑();
	      an.叫();
	将实例化猫换成实例化狗，狗就可以用有这些行为了，其他地方不用做任何修改。
	可是假如将蝴蝶也想复用Animal的代码，也去继承Animal的话，由于蝴蝶没有跑，叫的功能，所以没法复用，复用后就不是真正
	的蝴蝶了，除非修改Animal中定义的功能，将跑，叫的功能去掉。


# 依赖倒置原则(DIP--Dependence Inversion Principle)
+ 说明：1.要依赖于抽象，不要依赖于具体；2.抽象不应当依赖于细节；细节应当依赖于抽象；3.要针对接口编程，不针对实现编程。 
+ 优点：使用传统过程化程序设计所创建的依赖关系，策略依赖于细节，这是糟糕的，因为策略受到细节改变的影响。依赖倒置原则使细节和策略
  都依赖于抽象，抽象的稳定性决定了系统的稳定性。 
+ 怎样做到依赖倒置？ 
  1. 以抽象方式耦合是依赖倒置原则的关键。抽象耦合关系总要涉及具体类从抽象类继承，并且需要保证在任何引用到基类的地方都可以改换成其子类，
  因此，里氏代换原则是依赖倒转原则的基础。在抽象层次上的耦合虽然有灵活性，但也带来了额外的复杂性。如果一个具体类发生变化的可能性非常小，
  那么抽象耦合能发挥的好处便十分有限，这时可以用具体耦合反而会更好。 
  2. 层次化：所有结构良好的面向对象构架都具有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供一组内聚的服务。 
  3. 依赖于抽象：建议不依赖于具体类，即程序中所有的依赖关系都应该终止于抽象类或者接口。尽量做到： 
     1. 任何变量都不应该持有一个指向具体类的指针或者引用。 
     2. 任何类都不应该从具体类派生。 
     3. 任何方法都不应该覆写它的任何基类中的已经实现的方法。



    依赖倒转原则:
	->关于修电脑的实例.
	1.PC电脑:强内聚,低耦合.各个部件都是一个独立的模块,相互之间互不依赖.
	2.电脑各个部件之间的职责是单一的,如果某一部件坏了,直接更换该部件即可.显然,内存坏了,不应该成为更换主板的理由.
	3.无论主板,CPU, 内存,硬盘都是针对接口设计的.
	依赖倒转原则:1.高层模块不应该依赖低层模块,两个都应该依赖抽象.
			 2.抽象不应该依赖细节,细节应该依赖抽象(即针对接口编程,不要针对实现编程). 
	
	面向过程开发时,为了使常用代码能够复用,一般会把这些常用代码写成许许多多函数的程序库,我们在做新项目时,调用这些底层的
	函数就可以了.例如我们做项目大多需要访问数据库,于是把访问数据库的代码编写成函数,然后每次遇到新项目时,就去调用这些函数,
	这就叫高层模块依赖低层模块.
	
	但是问题来了,我们做完项目后,客户要求业务逻辑不变的情况下,更换数据库,这就出现麻烦了.由于高层模块和低层的访问数据库的
	模块是绑定在一起的,没办法复用这些高层模块.这就像PC,假如内存,CPU,硬盘都依赖具体的主板,如果主板一坏,所有部件都没
	用了,这个显然不合理.反过来,内存坏了,也不应该造成其他的部件不能用才对.所以不管高层模块,还是底层模块,都应该依赖抽象,
	具体点就是依赖抽象类或接口,只要接口稳定,那么任何一个更改都不用担心其他收到影响,这就使得无论高层模块还是底层模块都可以
	很容易的被复用.


# 接口隔离原则(ISP--Interface Segregation Principle)
+ 说明：使用多个专一功能的接口比使用一个的总接口要好。从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。
  过于臃肿的接口是对接口的污染，不应该强迫客户依赖于它们不用的方法。 
+ 优点：会使一个软件系统功能扩展时，修改的压力不会传到别的对象那里。 
+ 如何实现接口隔离原则？ <br/>
  不应该强迫用户依赖于他们不用的方法。 
  1. 利用委托分离接口;
  2. 利用多实现分离接口; 

# 迪米特原则(LOD or LKP--Law of Demeter or Least Knowledge Principle)
+ 说明：对象与对象之间应该使用尽可能少的方法来关联，避免千丝万缕的关系。 
+ 如何实现迪米特法则<br/> 
  迪米特法则的主要用意是控制信息的过载，在将其运用到系统设计中应注意以下几点： 
  1. 在类的划分上，应当创建有弱耦合的类。类之间的耦合越弱，就越有利于复用。 
  2. 在类的结构设计上，每一个类都应当尽量降低成员的访问权限。一个类不应当public自己的属性，而应当提供取值和赋值的方法让外界间接访问自己的属性。 
  3. 在类的设计上，只要有可能，一个类应当设计成不变类。 
  4. 在对其它对象的引用上，一个类对其它对象的引用应该降到最低。 


    迪米特法则(LOD):最少知识原则。
    如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法,
    可以通过第三者转发这个调用。
		
    迪米特法则强调在类的结构设计上，每一个类都应当尽量降低成员的访问权限，也就是说一个类包装好自己的private状态，不需要
    让别人知道的字段和行为就不要公开，需要公开的字段就用属性来体现。迪米特法则的根本思想就是强调类之间的松耦合。类之间的耦合
    越弱，越有利于复用。一个处于弱耦合的类被修改，不会对有关系的类造成波及。

    生活中的例子:
    1.比如家电的售后服务，我们不需要知道该家电企业的售后部具体某个人(也即是不必彼此通信)，当我们有维修需要时(需要调用该类的
      维修方法)时，直接一个电话打维修服务热线(对外访问的接口)，然后提报需求，直接调用接口定义的方法即可，我们完全不用关心具
      体来实现维修过程的子类是谁。
    2.又如企业各部门之间的具体成员，也没必要互相认识也不可能全都互相认识。当业务部门某员工的电脑坏了，需要找IT部门的修理时，
      只需要找行政部门专门负责此事的员工即可(如果行政部门有多人都可负责此事，那么找他们领导即可)，由他(她)帮我们找IT部们来处理，
      她也不可能找IT部门某具体员工，她找的是IT部门的主管。

    为什么各个类之间的通信越少越好(松耦合)？这样当一个类发生了变化，就不会影响其他类。比如某IT部门负责修电脑的员工突然辞职了，
    如果是通过上述方式访问的，就根本不会对业务部门造成任何影响，但是如果你平时是直接面向该员工的，那就会造成较大影响。

# 合成/聚合复用原则(CARP or CRP--Composite/Aggregate Reuse Principle or Composite Reuse Principle)
+ 说明：如果新对象的某些功能在别的已经创建好的对象里面已经实现，那么尽量使用别的对象提供的功能，使之成为新对象的一部分，而不要自己再
  重新创建。新对象通过向这些对象的委派达到复用已有功能的目的。简而言之，要尽量使用合成/聚合，尽量不要使用继承（侵入性太强）。 
+ 优点：
  1. 新对象存取成分对象的唯一方法是通过成分对象的接口；
  2. 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的；
  3. 这种复用支持包装； 
  4. 这种复用所需的依赖较少；  
  5. 每一个新的类可以将焦点集中在一个任务上； 
  6. 这种复用可以在运行时间内动态进行，新对象可以动态的引用与成分对象类型相同的对象； 
  7. 作为复用手段可以应用到几乎任何环境中去； 
+ 缺点: 系统中会有较多的对象需要管理。 