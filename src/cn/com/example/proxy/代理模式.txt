代理模式:为其他对象提供一种代理,以控制对这个对象的访问.应用的最多的还是控制真实对象的访问权限.除此之外,还有虚拟代理,远程代理等.
需求:卓贾谊不认识李娇娇,但是卓贾谊的好哥们戴利和李娇娇是同班同学,卓贾谊想追求李娇娇,
	于是通过戴利向李娇娇送芭比娃娃,送鲜花,送巧克力.写一个程序体现这种逻辑关系.
分析:1.涉及到的对象:卓贾谊,戴利,李娇娇.
	2.人物之间的关系,卓贾谊和戴利相互认识,戴利和李娇娇相互认识,但是卓贾谊和李娇娇相互不认识.
	3.属性:都有姓名属性.
	4.行为:送芭比娃娃,送鲜花,送巧克力.

阶段一:直接写定义两个类,分别是追求者,被追求者.然后追求者向被追求者展开追求行为.
	->1.人物关系没弄清楚,第一版代码反映的是卓贾谊亲自向李娇娇送礼物,但是实际情况是两者互相不认识的.
 	  2.凡是将1个对象作为参数传递给另一个对象的构造函数,那么这两个对象之间的关系只有4种可能:组合,聚合,关联,依赖.
                         除了这几种关系之外的,都不能直接把具体实例传递给构造函数.
                        本例把李娇娇对象作为参数传递给卓贾谊,但是卓贾谊并不知道李娇娇,所以,这种做法是错误的. 
                        
阶段二:在阶段一的基础上,将类名改成了Proxy,其他的不变.然后客户端运行时,将name改成里"戴利".
	 ->代码不重写,这样做的问题是变成了戴利追求李娇娇.与实际需求不符.
	
阶段三:由于追求者(卓贾谊),代理者(戴利)都具有相同的功能,送芭比娃娃,送鲜花,送巧克力.所以他们应该实现了一个共同的
	  接口---送礼物接口.
	  追求者不能直接送礼物,只需实现送礼物的接口即可.代理者也去实现送礼物的接口,不同的是它的实现方法是调用的追求者
	  的方法.
第三版代码的特点:
 * 1.从客户端是看不出真正送礼物的人是谁的.表面只能看到代理者戴利在送礼物,但实际运行结果是卓贾谊在送.
 * 2.追求者和代理者实现了同一接口,不同的是,代理者在其构造函数内部,创建了一个追求者(需被代理的对象)的实例,
 * 	其各种赠送行为时调用的追求者的行为.
 * 3.看上去和装饰设计模式很像,但是两者是有区别的:
 * 	 ->装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。
 * 	 ->装饰模式不需要对外隐藏其信息,所以通常在外部创建实例,然后将实例作为参数传递给装饰类.而代理模式,通常
 * 		需要隐藏被代理的对象,所以要在代理类的构造函数内部去创建一个被代理类.换句话 说，代理类（proxy）
 * 		可以对它的客户隐藏一个对象的具体信息。
 * 	 ->使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了(被代理类的实例创建在代理类内部)，
 * 	         而装饰模式者能够在运行时递归地被构造(多层包装),可以方便的随时改变包装次序和形式. 代理模式尽管
 * 	         也可以被多重代理,但是不能客户端不能随意变动.
 
 补充说明:1.本例其实追求者和代理者的姓名这个属性可以不要的,本例是增加了干扰性.
 		2.本例是纯粹的代理,代理者没有给被代理的行为添加其他功能,但是这是允许的.和装饰设计模式一样,可以增加一些内容的.
